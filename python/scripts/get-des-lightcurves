#!/usr/bin/env python
"""Get light curves of supernova candidates from DES database.

By default, the light curves are retrieved from the SNFORCE table, with
a query on SNCAND_ID. This behavior can be changed using the --table
flag. For the SNOBS table, the query is based on RA and DEC (within a
box of radius 1.08 arcsec). Note that the 'status' fields in the
SNFORCE and SNOBS tables have different meanings.  If no SNIDs are
given, all candidates with num_real >= 2 in the SNCAND
table are retrieved. Otherwise, only candidates with the given SNIDs
are retrieved (regardless of whether they have been scanned).
"""
import sys
import os
import glob
import math
import getpass
from datetime import datetime
import numpy as np
try:
    from collections import OrderedDict as odict
except ImportError:
    odict = dict
try:
    import cx_Oracle
except ImportError:
    print ("This script requires the cx_Oracle python package. "
           "Follow instructions at\n"
           "https://github.com/esheldon/desdb#dependencies\n"
           "exiting...")
    exit()
try:
    import desdb
except ImportError:
    print ("This script requires the desdb package:\n"
           "https://github.com/esheldon/desdb\n"
           "exiting...")
    exit()
try:
    import dessn
except ImportError:
    print "The dessn module must be installed or in $PYTHONPATH."
    exit()

# Get PasswordGetter for fetching db username.
# The location moves from one version of desdb to the next....
try:
    from desdb.desdb import PasswordGetter  # newer
except ImportError:
    from desdb import PasswordGetter # version on FNAL

from optparse import OptionParser

def main():

    parser = OptionParser(usage='%prog [options] [SNID ...]',
                          description=__doc__)
    parser.add_option("-n", type="int", default=0,
                      help="Maximum number of light curves to get. Default is"
                      " to get all the light curves.")
    parser.add_option("-a", "--all", default=False, action="store_true",
                      help="Get all candidates, regardless of cand_type. "
                      "Default is to get only candidates that have "
                      "cand_type=0 (indicating current, good).")
    parser.add_option("-t", "--table", default='snforce',
                      help="Table from which to retrieve photometry points. "
                      "Options: snobs, snforce (default: snforce)")
    parser.add_option("-f", "--format", default='csv',
                      help="File format for output. Options: "
                      "csv [default], json, fits, salt2, snana. Note: "
                      "The 'snana' format "
                      "is really only 'snana-ish': Additional metadata are "
                      "required in the files for snana to actually run.")
    parser.add_option("-b", "--bandnames", default='g,r,i,z',
                      help="Comma-separated list of names of the DES "
                      "g, r, i, z bands, as they should appear in the "
                      "output files. Example: desg,desr,desi,desz. Default: "
                      "g,r,i,z.")
    parser.add_option("-o", "--outputdir", default='.',
                      help="Output directory. Default is current directory.")
    parser.add_option("-c", "--clobber", default=False, action='store_true',
                      help="Overwrite (refetch) existing files.")
    parser.add_option("-v", "--verbose", default=False, action='store_true',
                      help="Print query string for all queries.")

    opts, args = parser.parse_args(sys.argv[1:])
    snids = args
    
    outdir = opts.outputdir
    if not os.path.exists(outdir):
        print "DIR must be an existing directory"
        sys.exit(1)
    outdir = outdir.rstrip('/')

    if opts.table not in ['snforce', 'snobs']:
        print "Table must be one of: snforce, snobs"
        sys.exit(1)

    if opts.format not in ['csv', 'snana', 'salt2', 'fits', 'json']:
        print "Format must be one of: csv, snana, salt2."
        sys.exit(1)
    suffix = {'csv': 'dat', 'snana': 'dat', 'salt2': 'dat', 'fits': 'fits',
              'json': 'json'}[opts.format]

    if opts.bandnames != 'g,r,i,z':
        names = opts.bandnames.split(',')
        if len(names) != 4:
            print "bandnames must have 4 comma-separated elements"
            sys.exit(1)
        bandnames = {'g': names[0], 'r': names[1], 'i': names[2],
                     'z': names[3]}
    else:
        bandnames = None

    # get database username
    user = PasswordGetter().user

    conn = desdb.connect()

    # Get candidate info from database.
    # If specific ids are NOT given, get everything marked as "SN"
    # in the snscan table.
    q = """
        SELECT DISTINCT
            snid, ra, dec, cand_type, cand_desc, numepochs, numobs, num_real, num_artifact, num_unsure, num_unscanned
        FROM
            sncand
        WHERE
            snfake_id=0
        """

    # if specific ids are not given, select candidates with num_real >= 2.
    if len(snids) == 0:
        q += """
        AND numepochs >= 2
        AND num_real >= 2
        """
        if not opts.all:
            q += "            AND cand_type=0\n"

    # otherwise, select the specific SNIDs.
    else:
        q+= "            AND snid in (" + ", ".join(snids) + ")\n"

    q += "        ORDER BY snid"

    if opts.verbose:
        print "CANDIDATE QUERY:"
        print q + "\n"

    cands = conn.quick(q)
        
    ncands = len(cands)
    if opts.n > 0:
        maxn = opts.n
    else:
        maxn = ncands

    print '',
    for i in range(maxn):

        cand = cands[i]
        fname = '{}/des{:08d}.{}'.format(outdir, cand['snid'], suffix)
        if not opts.clobber and os.path.exists(fname):
            continue

        print '\rsnid={:8d} ({:6d}/{:6d})'.format(cand['snid'], i+1, ncands),
        sys.stdout.flush()

        if opts.table == 'snforce':
            q = """
            SELECT
                substr(e.object, 22, 2) field, e.band, e.mjd_obs, f.flux,
                f.flux_err, f.status
            FROM
                exposure e, snforce f, image i
            WHERE
                f.sncand_id={:d}
                AND i.id=f.image_id
                AND e.id=i.exposureid
            ORDER BY
                e.mjd_obs
            """.format(cand['snid'])

        elif opts.table == 'snobs':
            q = """
            SELECT
                substr(e.object, 22, 2) field, e.band, e.mjd_obs, o.flux,
                o.flux_err, o.mag, o.status
            FROM
                exposure e, snobs o
            WHERE
                o.ra between {:f} and {:f}
                AND o.dec between {:f} and {:f}
                AND o.status=0
                AND o.exposureid=e.expnum
            ORDER BY
                e.mjd_obs
            """

            boxrad = 1.08 / 3600.
            ra = cand['ra']
            dec = cand['dec']
            dra = boxrad * math.cos(dec * math.pi/180.)
            ddec = boxrad
            q = q.format(ra - dra, ra + dra, dec - ddec, dec + ddec)
 
        if opts.verbose:
            print q
        data = conn.quick(q, array=True)

        # Convert band names, if requested.
        if bandnames is None:
            band = data['band']
        if bandnames is not None:
            band = []
            for b in data['band']:
                band.append(bandnames[b])

        # Add zeropoint information
        if opts.table == 'snforce':
            zp = 31.4
        elif opts.table == 'snobs':
            zp = data['mag'] + 2.5 * np.log10(data['flux'])

        data = odict([('time', data['mjd_obs']),
                      ('field', data['field']),
                      ('band', band),
                      ('flux', data['flux']),
                      ('fluxerr', data['flux_err']),
                      ('zp', zp),
                      ('zpsys', 'ab'),
                      ('status', data['status'])])

        # Create metadata.
        meta = odict()
        meta['query_user'] = user
        meta['query_time'] = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
        meta['query_utc'] = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S')
        meta['query_table'] = opts.table
        meta.update(cand)

        # Shorten some keywords, for fits format only.
        if opts.format == 'fits':
            meta['metatype'] = meta.pop('cand_type')
            meta['canddesc'] = meta.pop('cand_desc')
            meta['qry_user'] = meta.pop('query_user')
            meta['qry_time'] = meta.pop('query_time')
            meta['qry_utc'] = meta.pop('query_utc')
            meta['qry_tabl'] = meta.pop('query_table')

        # Add some metadata to 'meta' to conform to requirements
        #if opts.format == 'snana':
        #    meta['survey'] = 'DES'
        #    meta['filters'] = 'griz'
        #    meta['redshift_final'] = '999. +- 99.'
        #    if 'mwebv' not in meta: meta['mwebv'] = 0.

        dessn.write_lc(data, fname, meta=meta, fmt=opts.format, pedantic=False)

if __name__ == '__main__':
    main()
